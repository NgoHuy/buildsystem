#!/bin/bash

# Maintainer: Anh K. Huynh <kyanh@theslinux.org>
# Original Maintainer: Evangelos Foutras <evangelos@foutrelis.com>
# Original Contributor: Allan McRae <allan@archlinux.org>
# Original Contributor: Tom Newsom <Jeepster@gmx.co.uk>

# `sudo` has two different kinds of versions
#
#   x.y.z == x.y.z.0 -> x.y.z     : the main release (aka patch = 0)
#   x.y.z.t (t > 0)  -> x.y.z.pt  : the patches      (aka patch > 0)
#
_sudover="${PACKAGE_VERSION%.*}"
[[ "${PACKAGE_VERSION##*.}" == "0" ]] \
  || _sudover="${PACKAGE_VERSION%.*}p${PACKAGE_VERSION##*.}"

pkgdesc="Give certain users the ability to run some commands as root"
arch=('i686' 'x86_64')
url="http://www.sudo.ws/sudo/"
license=('custom')
groups=('base-devel')
depends=('glibc' 'pam')
backup=('etc/sudoers' 'etc/pam.d/sudo')
options=('!libtool')
source=("http://www.sudo.ws/sudo/dist/${pkgbase}-$_sudover.tar.gz"{,.sig}
        "sudo.pam" "new-default-sudoers.patch")

build() {
  cd "$srcdir/$pkgbase-$_sudover"
  patch -Np4 < "${srcdir}/new-default-sudoers.patch"
  ./configure \
    --prefix=/usr \
    --libexecdir=/usr/lib \
    --with-logfac=auth \
    --with-pam \
    --with-env-editor \
    --with-passprompt="[sudo] password for %p: " \
    --with-all-insults
  make
}

check() {
  cd "$srcdir/$pkgbase-$_sudover"
  make check
}

package() {
  cd "$srcdir/$pkgbase-$_sudover"
  make DESTDIR="$pkgdir" install

  install -Dm644 "$srcdir/sudo.pam" "$pkgdir/etc/pam.d/sudo"

  install -Dm644 doc/LICENSE "$pkgdir/usr/share/licenses/sudo/LICENSE"
}

# Notify if there is new version
#
# * The latest stable version
# * The latest patch for the current version
# * The link to them (!?)
#
# Strategy
#
# * Get the current version (x.y.z.t) and the first patch (x.y.z)
# * Fetch `sudo` homepage, and find the latest version started by `x.`
# * If the latest version equals to the current version, print the
#   update status, and exit (0)
# * If the latest version is not the current version, this indicates
#   that we have a new version to update. We provide the link to
#   this update. There are two cases
#   - It is on the same stream of the current version
#       the latest stable version == a patch update
#   - Otherwise,
#       the latest stable version == a major update
#       there is possibly new patch for the current version
#
# Output
#   sudo:
#     up-to-date: yes|nil
#     latest: the latest version if any
#     latest.link: link to the latest version information if any
#     update: the latest update if any
#     update.link: as `latest.link` but for `update`
#     error: user.input|curl.format|curl.error|curl.format.version
#
# Note:
#   1. The version string in the output is in TheSLinux format
#   2. The link in `update` can be used for the next tag
#
get_update() {
  local _url="http://www.sudo.ws/sudo/stable.html"

  echo "${PACKAGE_BASE}:"

  curl \
    --connect-timeout "${CURL_TIMEOUT:-3}" \
    -sL "$_url" 2>/dev/null \
  | ruby \
      -rnokogiri \
      -e "URL = '${_url}'" \
      -e "current_version = '$_sudover'" \
      -e '
        class String
          # Convert the Sudo string format to TheSLinux version string
          def new_format
            if self.include?("p")
              self.gsub("p", ".")
            elsif self.split(".").size < 4
              self + ".0"
            else
              self
            end
          end

          def version_valid?
            self.match(/^([0-9]+\.){2}[0-9]+(p[1-9]+)?$/)
          end
        end

        doc = Nokogiri::HTML(STDIN.read)
        ret = []
        current_stream = current_version.split(/[^0-9]/).slice(0,3).join(".")
        update_stream = ""
        major_stream = current_version.split(".").first

        # The current version information in format x.y.z.t
        unless current_version and current_version.version_valid?
          puts "  error: user.input"
          exit 1
        end

        # Find the latest stable version
        ver = doc.xpath("//a[starts-with(@name, \"#{major_stream}.\")]").first
        unless ver.respond_to?(:attributes)
          puts "  error: curl.format"
          exit 1
        end

        version = ver.attributes["name"].value
        unless version.version_valid?
          puts "  error: curl.format.version"
          exit 1
        end

        update_stream = version.split(/[^0-9]/).slice(0,3).join(".")
        if version == current_version
          puts "  up-to-date: yes"
          exit 0
        end

        if update_stream == current_stream
          ret << "  update: #{version.new_format}"
          ret << "  update.link: #{URL}##{version}"
          puts ret.join("\n")
          exit 0
        end

        ret << "  latest: #{version.new_format}"
        ret << "  latest.link: #{URL}##{version}"

        ver = doc.xpath("//a[starts-with(@name, \"#{current_stream}\")]").first
        if ver.respond_to?(:attributes)
          patch = ver.attributes["name"].value
          unless patch.version_valid?
            puts "  error: curl.format.version"
            exit 1
          end
          if patch == current_version
            ret << "  up-to-date: yes"
          else
            ret << "  update: #{patch.new_format}"
            ret << "  update.link: #{URL}##{patch}"
          end
        else
          ret << "  error: curl.format" if error
        end

        puts ret.join("\n")
      '

  [[ ${PIPESTATUS[0]} -eq 0 ]] \
  || { echo "  error: curl.error"; exit 1; }
}
